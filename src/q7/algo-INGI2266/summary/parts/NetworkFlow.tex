
\subsection{Graph reminder}

\subsubsection{Definitions}

\begin{description}
    \item[A directed graph] is tuple (V, E) where V is the set of vertices 
        and $E \in V x V$ is the set of edges.

    \item[A path] is a suite of distinct nodes $n_0, n_1, ... n_{(k-1)}$ with
        $\big(n_i, n_{(i+1)}\big)$ an
        edge for all $0 \leq i \le k-1$. 

    Node $n_0$ is the origin and node $n_{(k-1)}$ is the
        destination.

    \item[A cycle] is suite of distinct nodes  $n_0, n_1, ... n_{(k-1)}$ with
        $\big(n_i, n_{(i+1)}\% k\big)$ an edge for all $0 \leq i \le k$.
\end{description}

\subsubsection{Graph representation}

\begin{itemize}
    \item Adjacency matrix: The simples one but matrix don't take
        sparsity into account and linear time to iterate over adjacent
        nodes.

    \item Adjacency Lists

        \begin{center}
            \includegraphics[width=0.3\linewidth]{AdjacencyList.png}
        \end{center}
\end{itemize}


\subsubsection{DFS}

\begin{tabular}{m{6cm}m{6cm}m{3cm}}
    \begin{lstlisting}
DFS(V , E):
    // Initialization;
    Create global variable Color[1..|V |]
    Create global variable P arent[1..|V |]
    for each node $u \in V$ do 
        Color[u] = white
        Parent[u] = Nul
    // Start the search
    for each node $U \in V$ do
        if Color[u] = white then
            Visit(u, V, E)
    \end{lstlisting}
    &
    \begin{lstlisting}
Visit(u, V, E):
    Color[u] = Grey
    for $v \in Adj[u]$ do
        // Explore arc (u, v)
        if Color[v] = white then
            Parent[v] =  u
            Visit(v, V, E)
    Color[u] = black
    \end{lstlisting}
    &
    \begin{itemize}
        \item White: Unvisited
        \item Grey: Not all adjacent edge visited
        \item Black: Fully visited
        \end{itemize}
\end{tabular}

$\Rightarrow$ Say that as we are in a graph, we need to color node that we have
already explored so that we don't reexplore them. 

\paragraph{Complexity}
\begin{itemize}
    \item Init: $O(|V|)$
    \item $O(|V| + |E|)$ : As we have to check every edges at every node
        but we pass on each node once.
\end{itemize}

\subsection{Max flow}

Max flow is a combinatorial problem on Graphs.
He can be solved in polynomial time !

\subsubsection{Definitions}

\begin{itemize}
    \item \textbf{s} is the source and \textbf{t} is the sink
    \item $c(a, b)$ is the \textbf{capacity} between nodes $a$ and $b$.
        ($c(a, b)=0$ if there isn't a edge)

    \item $f(a, b)$ is the \textbf{flow quantity} between node $a$ and
        $b$. (A flow is a vector $f$ such that each composant is associated to a
        pair of nodes.)
$$f(a,b) = -f(a,b)$$ 
\end{itemize}

An \textbf{instance of the Max Flow problem} is characterized by the
graph $G = (V, E)$, the source $s$, the sink $t$ and the vector of
capacity $c$.

\paragraph{Constraints}
\begin{itemize} 
    \item \textbf{Flow conservation} constraint: the
        quantity of water entering into a node (different from
        source and sink) is exactly the same as the quantity of of
        water exiting this node.
        \begin{eqnarray*}
            \forall a\in V\{s,t\} & 
            \sum_{b|(b,a) \in E} \quad f(b,a)  &= \sum_{b|(a,b) \in E}
            \quad f(a,b) 
        \end{eqnarray*}
        Or equivalently
        \begin{eqnarray*}
            \forall a\in V\{s,t\} & 
            \sum_{b \in V} \quad f(a,b)  &= 0
        \end{eqnarray*}

\item \textbf{Capacity} constraint: the flow through each edge does
    not exceed the capacity of this edge.
    \begin{eqnarray*}
        \forall (a,b) \in E & f(a, b) \leq c(a, b)\\
        \forall (a,b) \notin E & f(a, b) \leq 0
    \end{eqnarray*}
\end{itemize}

\paragraph{Flow}
\begin{itemize} 
    \item A \textbf{valid flow} satisfies the two constraints
    \item A \textbf{null} flow is a valid flow where $f(a,b)=0$ for each
        edge
    \item The \textbf{value of a valid flow} is the water quantity out
        of the source. Because of the conservation flow constraint, this
        value is also equal to the quantity entering the sink.
        \begin{eqnarray*}
            v(f) =    \sum_{a \in V |(s,a) \in E} \quad f(s,a)  =
            \sum_{a \in V|(a,t) \in E}
            \quad f(a,t) 
        \end{eqnarray*}

    \item[$\Rightarrow$] The max flow problem is to discover a valid flow of
maximal value
\end{itemize}


\subsubsection{Resolution}

\textbf{Residual graph}Ø Gf = (V, Ef) are used to discover paths from the
source to the sink on which it is possible to push an
additional quantity of water and so increase the value of the
flow. This graph is composed of exactly the same nodes as the
original graph G = (V, E) but the edges may have a different
direction and a different (residual) capacity.

Basically if an edge is present only if it didn't reach it's maximal capacity and 
the residual capacity is is given by the quantity of the flow that can be added 
without violating the capacity of the edge.

A path joining the source s to the sink t in the residual graph Gf is
called \textbf{augmenting path}

\subsubsection{Graphical representation}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\linewidth]{MaxFlowGraphRepr.png}
\end{figure}
\FloatBarrier

For bidirectional edges, the reverse edge that we have will have the capacity of the second edge as shown in the example below.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\linewidth]{MaxFlowBidirectionnalRepresentation.png}
\end{figure}
\FloatBarrier

\subsubsection{Ford-Fulkerson Algorithm}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\linewidth]{MaxFlowAlgo.png}
\end{figure}
\FloatBarrier

Note : As is, the complexity of the algorithm is O(|V||E|U) with U the maximum flow of the graph. The complexity is thus not polynomial but pseudo-polynomial. For this algorithm to be polynomial you must use delta scaling. \newline

Delta scaling pseudocode :

\begin{lstlisting}
delta = X > 1
while true {
	Filter out all edges with capa < X in residual graph
	if you find an augmenting path :
		delta *= 2
		q = smallest capa of path
		for every edge of path do:
			f(a,b) = f(a,b) + q
			f(b,a) = f(b,a) - q
	else if delta > 1 :
		delta /= 2
	else
		break;
}
return result
\end{lstlisting}

As their are a maximum of log(U) iteration with delta scaling, the algorithm is of polynomial complexity. The complexity becomes O(|E|² log U)

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.55\linewidth]{MaxFlowAlgoExecutionExample.png}
    \caption{Ford-Fulkerson runtime example}
    \label{fig:Ford-Fulkerson_example}
\end{figure}

\subsubsection{Min flow}

\begin{figure}[!ht]
    \centering
    %\includegraphics[width=0.7\linewidth]{MinFlow.png}
\end{figure}

Be careful that in some problem negative weight may be used and infinite loop must thus be avoided. => Use the Moore-Bellman-Ford algorithm \url{https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm} 

\subsection{Min cut}

How much cut do we have to make to partition a graph such that two node s and t, are in different partition. Answer == MaxFlow(s,t)

\subsubsection{Definitions}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\linewidth]{CutDefinition.png}
\end{figure}
\FloatBarrier

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\linewidth]{CutDefinition1.png}
\end{figure}
\FloatBarrier

\subsubsection{Proof that min cut is solved by max flow}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\linewidth]{CutProof.png}
\end{figure}
\FloatBarrier
