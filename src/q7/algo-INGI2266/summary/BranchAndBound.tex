
\subsection{Definition}

A \textbf{branch-and-bound} algorithm consists of a systematic enumeration of candidate solutions by means of state space search: the set of candidate solutions is thought of as forming a rooted tree with the full set at the root. The algorithm explores branches of this tree, which represent subsets of the solution set. Before enumerating the candidate solutions of a branch, the branch is checked against upper and lower estimated bounds on the optimal solution, and is discarded if it cannot produce a better solution than the best one found so far by the algorithm.

\subsection{Solving the knapsack problem with B\&B}

Given the following knapsack problem :

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.4\linewidth]{KnapsackBBProblem.png}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

We can choose to relax either of the constraint during the branch and bound procedure 
as to obtain a solution. The goal being to reduce the search space as much as possible
by calculating an upper bound as precise as possible.
Let us thus compare both options in the following sections.

\subsubsection{Capacity relaxation}

The first constraint that we can relax is the capacity constraint. The B\&B
calculation becomes fairly simple to implement as we only cut at tree branch when 
we have surpassed the capacity. The search space is thus reduced as such :

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{KnapsackBBCapaRelaxation.png}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

Which, as you can see, is far from optimal as our upper bound are not close enough to their
real value.

\subsubsection{Linear relaxation}

This second relaxation is slightly harder to implement but yields better result, as 
the upper bound approximation is far better. Given a set sorted by ratio $v_i/w_i$,
the upper bound calculation procedure become as search for the first critical item j.
\newline

The first critical item j being the first item which cannot be fully added in our selection
due to capacity constraint. 

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.4\linewidth]{KnapsackBBCriticalItem.png}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

The upper bound can then be calculated as the sum of all item i < j plus as much of j
as we can squeeze in while respecting the capacity constraint.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.5\linewidth]{KnapsackBBLinearRelaxationUB.png}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

The search space is thus reduced as such :

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{KnapsackBBLinearRelaxation.png}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

As you can see, improving the precision of the upper-bound yields far better result. Take care however not to over/under estimate it (depending if you are on a maximisation or minimisation process) as it might prevent you to find the optimal solution.

\subsection{B\&B pseudo-code}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\linewidth]{PseudoCodeBB.png}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

With the preceding algorithm, a partial solution will be represented as a growing vector
of zero and ones representing whether a given item as been selected or not.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{PartialSolBB.png}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

This algorithm however has limitations, we must always evaluate the variables of the 
problem in the same order (We cannot affect $X_1$ then$ X_2$ at the left side of the tree 
while on the other side we affect $X_2$ then $X_1$, each level of the tree must strictly 
correspond to the affectation of a variable). As affecting variable in different order may result in better performance, this a limitation.\newline

We also cannot process trees which posses a variable number of children easily with this method. If it was possible we could, for example, decide multiple variable at once
and thus increase the performances of our algorithm. \newline

We must find a way to implement reversible states to improve our algorithm further
by breaking those two limitations. The space usage of those reversible state must however
be relative the the change that have been made on the parent. We do not want to simply
clone the parent and waste memory.

\subsection{Reversible state and magical integers}

To implement those reversible states, we will thus make use of three objects.

\begin{enumerate}
	\item \textbf{ReversibleContext()} : Which will be used to represent a 
	reversible state.
	\item \textbf{ReversibleInt(ReversibleContext rc, int i)} : Which will be used to 
	represent the variables of a reversible state.
	\item \textbf{TrailEntry(ReversibleInt ri, int value)} : Which will be used
	to represent changes on a stacks stocked in the context. This object will
	only be used by the ReversibleContext class.
\end{enumerate}

Using those three object can then implement an reversible context 
which can be used as shown in the following piece of code :

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{ReversibleIntegerIntroductionBB.png}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

Which the push pop operation acting as follows:

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\linewidth]{ReversibleStatePushPop.png}
    \caption{Push/Pop implementation in reversible context}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

\subsection{Reversible state implementation}

\#Ca pue l'exam les gars

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.1\linewidth]{ReversibleStateImplementation.png}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

The slides (lecture 2 page 28) contains an implementation of B\&B using branch and bound
which we will not place here as it is highly unlikely that we will be interrogated on it.
Also if you have understood reversible context then it should be fairly easy 
to reimplement in the worst case scenario.

\subsection{Search heuristics}

So far we have always added items on the left side of the tree (affecting variable to 1)
and removed items on the right side. We have also always affected variable sequentially, 
in the same order each time\newline

Now that we can traverse the tree as we want, we can change that and make use of 
heuristics which, at each given moment, decide what variable to instantiate 
and/or which value to assign. 
\newline

In a Branch and bound algorithm, finding good solution faster is better 
as the pruning will become more effective.
Heuristic will also result in a better \textbf{anytime behavior} (the quality of the best
solution you have if you stop the search after a time limit).  \newline

\subsubsection{Iterative Discrepancy Search}

Discrepancy = Number of right (the side in a tree) decisions

If i posses a trustworthy heuristic where interesting sub tree are on the left of a parent,
using a limited discrepancy search would be a good optimisation as wrong decision often
take place in early stages.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\linewidth]{LimitedDiscrepancySearch.png}
    \label{fig:Knapsack_example}
\end{figure}
\FloatBarrier

As you can see with this method we rapidly find good solution which will help the pruning
during the following iterations. We thus obtain a potentially fast and complete algorithm
(depending on the heuristic). If the heuristic is not significant however the algorithm will
be far slower as it involves much re computation (which normally won't be too signifiant
thanks to the pruning).\newline

\textbf{If the discrepancy search does not explore the tree completely, 
it is not considered complete !} This can however be used as a form of greedy
algorithm.

\subsubsection{Best first search}

Expand the open node with the best upper-bound first (maximization) !
Although fairly efficient and easy to implement, this heuristic has two drawbacks :

\begin{enumerate}
	\item You won't have a feasible solution directly (implication for the pruning).
	\item Memory usage is difficult to control.
\end{enumerate}

\subsubsection{Other heuristics}

TODO

\subsection{Other B\&B optimisations}

\subsubsection{Symmetry detection}

In case of symmetric items in the knapsack set (understand identical), we can reduce the
search space significantly as the items are completely interchangeable.\newline

For example given four symmetrical items $(X_{n+1}, X_{n+2}, X_{n+3}, X_{n+4})$, 
their assignment tree would normally contain 16 elements $(2^4)$ but it can 
be reduced to five due to their symmetrical property. 
We only need to explore the following states:

\begin{enumerate}
	\item (0,0,0,0) => take 0
	\item (1,0,0,0) => take 1
	\item (1,1,0,0) => take 2
	\item (1,1,1,0) => take 3
	\item (1,1,1,1) => take 4
\end{enumerate}

\subsubsection{Dominance detection}

In case an item b is dominated by another item a
(b is dominated by a if $V_a \geq V_b \wedge W_a \leq W_b$)
It is never interesting to take b if a is not also taken ! \newline

An optimal solution cannot have a = 0 and b = 1. 
We can thus avoid to explore such states.



