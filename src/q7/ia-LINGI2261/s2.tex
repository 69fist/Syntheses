\section{Chapter 3.1 to 3.4: Solving problems by searching}

\subsection{Key principles}

\begin{description}
\item[Search] process of looking for a (or the best) sequence of actions, that leads to a goal (specific state of the environment), starting from an initial state
\item[States] distinguishables stages during the problem solving process (representation of physical configuration)
\item[State space] is graph representation of the successor function with the cost
\item[Initial state] \textit{to complete}
\item[Action] an action transports the agent from one state to another one by applying an \textit{operator} to a state
\item[Operators] \textit{to complete}
\item[Goal test] \textit{to complete}
\item[Path cost] \textit{to complete}
\item[Solution] a solution is a sequence of actions leading from the initial state to a goal state
\item[Optimal solution] an optimal solution has the lowest path cost among all solutions
\item[Node] data structure constituting part of a search tree
\item[Frontier] set of generated nodes, which ancestors have been goal-tested (visited)
\end{description}

\subsection{Searching for Solutions}

Searching for solutions is a traversal of some search space from the \textit{initial state} to the \textit{goal state} using a legal sequence of actions (as defined by operators).

\begin{enumerate}
\item Check if current state is a goal state
\item Expand the current state
\begin{enumerate}
\item Determine the set of reachable states
\item Return "failure" if the set is empty
\end{enumerate}
\item Select one state from the set of reachable states
\item Move to the selected state
\end{enumerate}

\subsection{Tree versus Graph Search}

There is two way to perform the search\footnote{the slides specifies an algorithm to search in a tree}.
\begin{itemize}
\item \textbf{A graph representing the state space}: you represent all the possible states as a graph, and you move between those states
\item \textbf{A search tree}: you list all the possibilities from the current states using the possible \textit{operators}
\end{itemize}
\subsection{Search strategies}
There is two types of search: \textbf{uninformed search} where the only information known by the agent is \textit{Am I on the goal?} and the \textbf{informed search} where agent has a background information about the problem.

We can evaluate a search strategy with 4 criterias:
\begin{itemize}
\item \textbf{Completeness}: it finds a solution if one exists
\item \textbf{Time complexity}: usually in terms of the number of nodes generated/expanded
\item \textbf{Space complexity}: maximum nodes in memory
\item \textbf{Optimality}: it finds a least cost solution?
\end{itemize}
And you use 3 differents variables:
\begin{itemize}
\item[$\textbf b$] maximum branching factor of the search tree (the maximum number of subnodes)
\item[$\textbf d$] depth (in the tree) of the least-cost solution
\item[$\textbf m$] maximum depth of he search tree (may be infinite)
\end{itemize}

\subsection{Graph search}

Here will be presented different algorithm to search in a tree.

\subsubsection{Algorithm: Breadth-First Search}
Breadth-First is an example of \textit{uninformed search}. The goal is to search in a tree level by level from "left" to "right".

You start from the root node and adds the subnodes at the end of a 
\textcolor{red}{FIFO queue} (the queue beeing the \textit{frontier}). 

\paragraph{Criteria}
This solution is \textit{complete} (if b is finite), and \textit{optimal} if the cost per
step is 1 (but in general use it ain't \textit{optimal}).

\paragraph{Complexity}
it has a \textit{time complexity} of $O(b^d)$\footnote{Time complexity: $1+b+b^2+...+b^d+b(b^d-1) = O(b^{d+2}) = O(b^d)$} and a \textit{space complexity} of $O(b^d)$. 

\begin{figure}[H]
\centering
\begin{tabular}{|llll|}
\hline
\textbf{Depth} & \textbf{Nodes} & \textbf{Time} & \textbf{Memory} \\
\hline
2 & 1100 & 0.11 seconds & 1 Mb \\
4 & 111100 & 11 seconds & 106 Mb \\
6 & $10^7$ & 19 minutes & 10 Gb \\
8 & $10^9$ & 31 hours & 1 Tb \\
10 & $10^{11}$ & 129 days & 101 Tb \\
12 & $10^{13}$ & 35 years & 10 Pb \\
14 & $10^{15}$ & 3523 years & 1 Eb \\
\hline
\end{tabular}
\caption{Breadth-First Search Evaluation}
\end{figure}

\subsubsection{Algorithm: Uniform-Cost search}

Uniform-Cost is another example of \textit{uninformed search}. This is similar to Breadth-First but with a cost adedd the the reachable nodes. Le \textit{path cost} is simply the sum of the individual edge costs to reache the current node. \textit{Frontier} is now a queue ordered by the path cost.

\paragraph{Criteria}
This algorithm is \textit{optimal} compare to Breadth-First, it is \textit{complete} if step cost is strictly positive.

\paragraph{Complexity}
\textit{time and space complexity} are difficult to establish (it depends on the tree), we evaluate it with $O(b^{C/\epsilon}$.\footnote{$C$ is the cost of the optimal solution and $\epsilon$ the step cost strictly positive}

\subsubsection{Algorithm: Depth-first Search}

Another exemple, where the \textit{frontier} is implemented as a \textcolor{red}{LIFO queue}. Concretly, we go to the last depth and then go back up.

\paragraph{Criteria}
This algorithm isn't \textit{complete}, as you can fall in infinite depth spaces. The \textit{time complexity} is $O(b^m)$ 

\paragraph{Complexity}
The \textit{space complexity} is $O(mb)$. \textbf{It is not an \textit{optimal} algorithm}.

\subsubsection{Algorithm: Depth-Limited Search}

It is the same as a \textit{Depth-first} but with a depth-limit. 

\subsubsection{Algorithm: Iterative Deepening}

Let $l$ be a limit. This algorithm is a Depth-Limited, but we increase the depth limit as we search. It combines advantage of Breadth-First and Depth-First methods. In this techniques many nodes are visited multiple times but it doesn't really matter beacause the number of those nodes is "small".

This algorithm is \textit{complete}, it has a \textit{time complexity} of $O(b^d)$ and a \textit{space complexity} of $O(bd)$. This is an \textit{optimal} algorithm.

\textbf{TODO: complete the explanation of why the space is linear now}

\subsubsection{Algorithm: Bidirectionnal Search}

We use Breadth-First search and we stop when two search trees intersects. There is a few difficulties with this type of search:
\begin{itemize}
\item Predecessors of a state must be generated\footnote{Quelqu'un peut-il expliquer?}
\item Search must be coordinated between the two search processes
\item Multiple goal states?
\item One serach must keep all nodes in memory
\end{itemize} 

This algorithm is \textit{complete}, it has a \textit{time complexity} of $O(b^{d/2})$ and a \textit{space complexity} of $O(b^{d/2})$. It's an optimal algorithm is step cost is 1 (like in Breadth-First). 

\begin{figure}[H]
\centering
\begin{tabular}{|l|cccccc|}
\hline
& \textbf{BF} & \textbf{UC} & \textbf{DF} & \textbf{DL} & \textbf{ID} & \textbf {BS}\\
\hline
\textbf{Completeness} & YES & YES & NO & YES if $l\geq d$ & YES & YES\\
\textbf{Time} & $b^{d+1}$ & $b^{C/\epsilon}$ & $b^m$ & $b^l$ & $b^d$ & $b^{d/2}$\\
\textbf{Space} & $b^{d+1}$ & $b^{C/\epsilon}$ & $bm$ & $bl$ & $bd$ & $b^{d/2}$ \\
\textbf{Optimallity} & YES & YES & NO & NO & YES & YES \\
\hline
\end{tabular}
\caption{Graph Search Algorithm}
\end{figure}

\subsection{Repeated States}

Failure to detect repeated states can turn a solvable problems into unsolvable ones. We are going to avoid visiting nodes that have already been visited. 
