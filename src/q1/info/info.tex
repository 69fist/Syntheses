\input{../../lib.tex}

% cfr http://en.wikibooks.org/wiki/LaTeX/Colors
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\usepackage{appendix}

\usepackage{listings}
\usepackage{numprint}

\hypertitle{Informatique}{1}{1401}{Benoît Legat}{Benoît Legat}

\definecolor{dkgreen}{rgb}{0.25,0.7,0.35}
\definecolor{dkred}{rgb}{0.7,0,0}
\lstset{language={Java},numbers=left,numberstyle=\tiny\color{gray},
basicstyle=\rm\footnotesize,keywordstyle=\bfseries\color{dkred},frame=single,
commentstyle=\color{gray}=small, stringstyle=\color{dkgreen}}

\part{Instructions, expressions et variables}

\section{Instructions}
Un programme est composé principalement d'instructions qu'il exécute l'une à la
suite de l'autre.

Chaque instruction se termine par un \verb|;|, on les met tout le temps
une par ligne pour aider à la lecture du programme mais le compilateur
pourrait comprendre le programme s'il n'était que sur une seule ligne.

On regroupe parfois des instructions par bloc avec des accolades
(\verb|{| et \verb|}|).
\begin{lstlisting}
{
  instruction1;
  instruction2;
  ...
  instructionn;
}
\end{lstlisting}

\section{Expressions}

Un composé fondamental de ces instructions est l'expression.
Ces expressions sont composée d'opérations entre d'autres expressions.
Une valeur ou une variable sont tous les deux des expressions.
Chaque expression est évaluée lors de l'exécution du programme.

\section{Variables}
Dans un programme, on utilise des variables comme en mathématiques.
Par contre, en informatique, les variables peuvent changer de valeur.

Chaque variable a un type et en Java, on ne peut pas changer son type.

Pour créer une variable, il faut lui donner un type et ce type ne changera
plus par la suite.
\subsection{Types}
Il y a deux sortes de type en Java, les types primitifs et les classes.

Il y a 8 types primitifs mais les plus importants sont les
\begin{itemize}
  \item \verb|int|, ce sont des nombres entiers, ils valent par exemple
    \verb|0| ou \verb|-8| ou encore \verb|42|;
  \item \verb|double|, ce sont les nombres à virgule, il valent par exemple
    \verb|3.14| ou \verb|1.41|;
  \item \verb|char|, ce sont les charactères, il valent par exemple \verb|'a'|
    ou \verb|'A'| ou \verb|'0'| ou même un retour à la ligne \verb|'\n'|;
  \item \verb|boolean|, ils valent \verb|true| ou \verb|false|;
\end{itemize}
Les autres sont comme les \verb|int| ou les \verb|double| mais utilisent plus
ou moins de mémoire. Cependant, à l'époque actuelle, la mémoire n'est plus
si limitée et ils sont moins utilisés.

Par contre il est important de remarquer ces deux types qu'ils ne savent
pas contenir des nombres d'une taille arbitraire, ils ont chacun leur limite
\begin{itemize}
  \item Un \verb|int| sait seulement contenir un entier appartenant à
    $[-2^{31}; 2^{31}[$. On retient que
    \[ 2^{31} = 2 \cdot \left(2^{10}\right)^3 = 2 \cdot (1024)^3
    \approx 2 \cdot (1000)^3 = \numprint{2e9} \]
  \item Un \verb|double| retient un nombre à virgule flottante, c'est à dire
    qu'il le retient en écriture scientifique.
    Il retient ses décimales et la puissance de 10.
    Il peut donc être très grand mais n'est pas si précis que ça.

    Vous pouvez vous en apercevoir en vérifiant que l'expression
    \begin{lstlisting}
0.1 + 0.2 == 0.3
    \end{lstlisting}
    est évalué à \verb|false|.
    C'est du au fait que les décimales sont écrite en binaire dans la mémoire
    et que ces nombres ne sont pas si rond en binaire.

    En règle générale, on ne test jamais l'égalité entre deux \verb|double|
    mais plutôt la valeur absolue de leur différence.
\end{itemize}

\subsection{Manipulation de variables}
On peut utiliser les variables de 3 manières différents, on peut les créer,
leur assigner une valeur et la lire dans une expression.
Dans les exemples de cette sous-section, on considèrera qu'on utilise des
\verb|int| mais c'est évidemment le même principe pour les autres types
primitifs.

\subsubsection{Création d'une variable}
Pour créer une variable, il faut lui choisir un nom qui n'est pas encore
utilisé, il ne peut pas commencer par un chiffre mais peut contenir chiffres,
lettres et underscores (\verb|_|).

Supposons qu'on crée un \verb|int| qu'on appelle \verb|foobar|.
\begin{lstlisting}
int foobar;
\end{lstlisting}
Lors de leur création, les variables sont initialisées à \verb|0| ce qui pour
les \verb|boolean| signifie \verb|false|.

On peut aussi donner une valeur lors de l'initialisation de la variable
comme dans l'exemple suivant
\begin{lstlisting}
int foobar = 1;
\end{lstlisting}

\subsubsection{Assignation}
On peut modifier la valeur d'une variable à tout moment du programme en lui
assignant la valeur d'une expression. Il faut bien évidemment que la valeur
de l'expression soit du même type. La syntaxe est la suivante
\begin{lstlisting}
foobar = expression;
\end{lstlisting}

Il est important de remarquer que le \verb|=| de l'assignation n'est pas le
même qu'en mathématique, on peut par exemple faire
\begin{lstlisting}
foobar = foobar + 1;
\end{lstlisting}

Dans ce cas ci, il est important d'insister sur l'ordre à l'exécution.
On évalue d'abord le membre de droite qui n'est rien d'autre qu'une expression
puis on assigne cette valeur dans le membre de droite.

\subsubsection{Les raccourcis}
Certaines assignations sont très courrantes, elles possèdent donc un raccourcis.
\begin{lstlisting}
foo = foo + bar;
\end{lstlisting}
peut s'écrire
\begin{lstlisting}
foo += bar;
\end{lstlisting}
Il y a des raccourcis similaire pour les opérateurs
\verb|-|, \verb|*| et \verb|/|.

Encore plus raccourcis, au lieu d'écrire
\begin{lstlisting}
foo += 1;
\end{lstlisting}
on peut écrire
\begin{lstlisting}
foo++;
\end{lstlisting}
Il y a un raccourci pour l'opérateur \verb|-|.

\section{Les opérateurs}
Les expressions seraient bien pauvres si on ne pouvait pas les manipuler
entre elles.
Il existe les opérateurs suivants dont le résultat est du même type
que les deux variables sur lesquels ils sont appliqués
\begin{center}
  \begin{tabular}{|c|l|}
    \hline
    \verb|a + b| & Vaut la somme de \verb|a| et \verb|b|\\
    \hline
    \verb|a - b| & Vaut la soustraction de \verb|a| par \verb|b|\\
    \hline
    \verb|a * b| & Vaut la multiplication de \verb|a| et \verb|b|\\
    \hline
    \verb|a / b| & Vaut la division de \verb|a| par \verb|b|\\
    \hline
    \verb|a % b| & Vaut le reste de la division euclidienne
    de \verb|a| par \verb|b|\\
    \hline
  \end{tabular}
\end{center}
Il existe aussi des opérateurs dont le résultat est un \verb|boolean|
\begin{center}
  \begin{tabular}{|c|l|}
    \hline
    \verb|a == b| & Vaut \verb|true| si \verb|a| est égal à \verb|b|\\
    \hline
    \verb|a != b| & Vaut \verb|true| si \verb|a| est différent de \verb|b|\\
    \hline
    \verb|a < b| & Vaut \verb|true| si \verb|a| est plus petit
    strictement que \verb|b|\\
    \hline
    \verb|a <= b| & Vaut \verb|true| si \verb|a| est plus petit
    ou égal à \verb|b|\\
    \hline
    \verb|a > b| & Vaut \verb|true| si \verb|a| est plus grand
    strictement que \verb|b|\\
    \hline
    \verb|a >= b| & Vaut \verb|true| si \verb|a| est plus grand
    ou égal à \verb|b|\\
    \hline
  \end{tabular}
\end{center}

Tous ces opérateurs sont des opérateurs binaires car ils recquièrent deux
valeurs.
Il existe aussi un opérateur unaire et un opérateur ternaire
\begin{center}
  \begin{tabular}{|c|l|}
    \hline
    \verb|!a| & Vaut \verb|true| si \verb|a| vaut \verb|false| et
    vaut \verb|false| sinon\\
    \hline
    \verb|a ? b : c| & Vaut \verb|b| si \verb|a| vaut \verb|true| et
    vaut \verb|c| sinon\\
    \hline
  \end{tabular}
\end{center}

\part{Structures de contrôle}
Quand on éxecute un programme, les instructions se font exécuter l'une après
l'autre, dans l'ordre dans lequel elles ont été écrites.

Seulement, il existe des moyens de passez outre cet ordre.

\paragraph{Les conditions}
Une condition est toute expression s'évaluant en \verb|boolean|.

\section{Les structures conditionnelles}
Il est possible d'exécuter un bloc d'instruction seulement si une condition
est vraie.
\begin{lstlisting}
if (condition) bloc
\end{lstlisting}
Le bloc sera exécuté seulement si la condition vaut \verb|true|.

Il est possible de demander d'exécuter un autre bloc si la condition est fausse.
\begin{lstlisting}
if (condition) bloc1
else bloc2
\end{lstlisting}
Si la condition vaut \verb|true|, le premier bloc sera exécuté, sinon, le
second bloc sera exécuté.

\section{Les boucles}
Une boucle exécute un bloc \emph{tant que} la condition est vraie.
Avant chaque exécution du bloc, il vérifie si la condition vaut \verb|true|.
Si c'est le cas, le bloc est exécuté.
Sinon, le programme poursuit son court.

La syntaxe est fort semblable au \verb|if|.
\begin{lstlisting}
while (condition) bloc
\end{lstlisting}

\appendix
\section{Écrire, compiler et exécuter}
Nous allons différencier la programmation par IDE et en console.
Les remarques sur l'écriture, la programmation et la compilation
sont dans la partie console mais elles valent aussi pour la
programmation à travers un IDE.

\subsection{IDE}
Un \textbf{IDE} (\textbf{I}ntegrated \textbf{D}evelopment \textbf{E}nvironment)
fourni un éditeur de texte et des boutons pour compiler et exécuter.
Tout ça avec une interface graphique.

Pour Java, on peut citer notamment
\begin{itemize}
  \item Eclipse;
  \item Netbeans;
  \item BlueJ.
\end{itemize}
Ils sont tous les trois libres donc gratuits.

\subsection{Console}
Programmer en console signifie utiliser
l'éditeur de texte et le compilateur séparément.
On appelle ça programmer à la console car on appelle souvent le compilateur
et on exécute le programme à travers l'invite de commande.

Supposons qu'on crée le projet \verb|Foobar| contenant la classe
\verb|Foo| et la classe \verb|Bar|,
la méthode \verb|main| étant dans la classe \verb|Foo|.

Une structure classique serait de placer \verb|Foo.java| et \verb|Bar.java|
dans un dossier \verb|src/| et placer un fichier \verb|README|
à la racine du projet expliquant brièvement ce que fait le programme.

\subsubsection{Se déplacer dans la console}
Dans une console, on se situe toujours dans un dossier.
Lorqu'on ouvre une console, on se trouve dans le dossier personnel.
Pour savoir dans lequel on se trouve,
exécutez la commande suivante
(\textbf{P}rint \textbf{W}orking \textbf{D}irectory):
\begin{lstlisting}[language={sh}]
$ pwd
/home/jean
\end{lstlisting}

Pour voir les fichiers dans le dossier courant, exécutez la commande suivante:
%TODO: LiSt ou List Segments ?
\begin{lstlisting}[language={sh}, morekeywords={ls}]
$ ls
Desktop                    Music                Templates
Documents                  Pictures             Videos
Downloads                  Public
\end{lstlisting}

Pour se déplacer, il faut utiliser la commande
\verb|cd| (\textbf{C}hange \textbf{D}irectory).
\begin{lstlisting}[language={sh}, morekeywords={xx}]
$ cd Documents
$ pwd
/home/jean/Documents
$ cd ..
$ pwd
/home/jean
\end{lstlisting}

\subsubsection{Écrire}
Pour écrire \verb|Foo.java|, \verb|Bar.java| et \verb|README|,
il nous faut un éditeur de texte.

\begin{itemize}
  \item Sur Linux, les plus simples sont {\em Gedit} et {\em Kate};
  \item Sur Mac OS, {\em TextMate} est un excellent choix;
  \item Sur Windows, je conseille {\em Notepad++}.
\end{itemize}

Il y en a plein d'autre évidemment. Comment ne pas citer {\em Emacs} et
{\em Vim} qui, bien qu'étant très anciens, sont considérés par beaucoup
pour être les plus complets et les plus puissants.
Attention néanmoins, la {\em learning curve} de ces derniers est assez raide.

Si vous n'avez pas d'interface graphique et que vous ne voulez pas utiliser
un éditeur de texte aussi compliqué que {\em Emacs} ou {\em Vim}, considérez
{\em nano} ou {\em pico}.

Pour lancer un éditeur de texte depuis la console,
positionnez-vous dans le même dossier que le fichier à ouvrir
et exécutez la commande suivante:
\begin{lstlisting}[language={sh}, morekeywords={vim}]
$ vim Foo.java
\end{lstlisting}
Pour un éditeur de texte graphique,
il vaut mieux l'appeler ajouter un \verb|&| pour qu'il s'exécute en
background et que l'invite de commande ne se bloque pas:

\begin{lstlisting}[language={sh}, morekeywords={gedit}]
$ gedit Foo.java &
\end{lstlisting}

\subsubsection{Compiler}
Il faut compiler chaque classe en fichier \verb|.class|.
Pour cela, la commande à utiliser est \verb|javac|.
Avec un terminal ouvert et positionné dans le fichier \verb|src/|,
exécutez la commande suivante:
\begin{lstlisting}[language={sh}, morekeywords={javac}]
$ javac Foo.java Bar.java
\end{lstlisting}
Notez que l'ordre entre les fichiers \verb|.java| n'a aucune importance.

\subsubsection{Exécuter}
À nouveau, ouvrez un terminal et positionnez le dans le fichier \verb|src/|.
Il dire à {\em Java} dans quelle classe se trouve la méthode \verb|main|.
Dans notre cas, c'est dans la classe \verb|Foo|.
Dès lors, exécutez la commande suivante:
\begin{lstlisting}[language={sh}, morekeywords={java}]
$ java Foo
\end{lstlisting}
Notez qu'on écrit pas d'extension à \verb|Foo|, on écrit ni \verb|Foo.java|
ni \verb|Foo.class|.

\end{document}
